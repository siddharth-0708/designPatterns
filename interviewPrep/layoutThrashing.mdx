---
title: Layout Thrashing â€” Notes
description: Complete explanation of layout thrashing, why it happens, how it affects the event loop and vsync, and how to avoid it with correct coding patterns.
---
IMPORTANTT:
##Forced Synchronous Layout

If layout is dirty and a layout read occurs, the browser **must immediately recalculate layout**, blocking JavaScript execution.

This is called a **forced reflow**.


# Layout Thrashing â€” Complete Notes

---

## 1. What Is Layout Thrashing?

**Layout thrashing** occurs when JavaScript repeatedly forces the browser to synchronously recalculate layout by **interleaving DOM writes and layout-dependent reads**.

This causes:
- Multiple forced reflows
- Main thread blocking
- Missed frames and jank

---

## 2. How Browsers Normally Optimize Layout

Browsers are **lazy and optimized**.

When JavaScript writes to the DOM:

```js
el.style.width = '100px';

The browser does not immediately recalculate layout.

Instead it:

1. Marks styles as dirty

2. Marks layout as dirty

3. Defers layout until rendering

This batching is crucial for performance.

3. The Critical Rule (Core Concept)

Layout reads require the layout tree to be clean.

Layout-dependent reads include:

offsetWidth

offsetHeight

getBoundingClientRect()

clientWidth, clientHeight

scrollTop, scrollHeight

If layout is dirty and JavaScript performs one of these reads, the browser must immediately recalculate layout.

This is called a forced synchronous reflow.

4. How Layout Thrashing Happens
âŒ WRONG: Interleaving Reads and Writes
el.style.width = '100px';   // WRITE â†’ layout marked dirty
el.offsetWidth;             // READ â†’ forced layout

el.style.height = '200px';  // WRITE â†’ layout dirty again
el.offsetHeight;            // READ â†’ forced layout again

What the Browser Is Forced to Do
WRITE â†’ layout dirty
READ  â†’ recalc layout now
WRITE â†’ layout dirty
READ  â†’ recalc layout now


Layout is recalculated multiple times in one JS task â€” this is layout thrashing.

5. Why Layout Thrashing Is Harmful
1. Blocks the Main Thread

Layout is synchronous

JavaScript execution pauses until layout finishes

2. Breaks the Frame Budget

60fps â‰ˆ 16.6ms per frame

Multiple layouts can exceed this easily

3. Causes Jank

Missed vsync

Dropped frames

Scroll hitching

Input lag

6. Layout Thrashing in the Event Loop & VSync
Healthy Frame
JS runs
â†“
Layout (once)
â†“
Paint
â†“
Composite
â†“
VSync

Thrashing Frame
JS â†’ Layout â†’ JS â†’ Layout â†’ JS â†’ Layout
âŒ Rendering delayed
âŒ VSync missed


Layout thrashing happens during the JS phase, before rendering begins.

7. requestAnimationFrame Does NOT Automatically Fix Thrashing

Using requestAnimationFrame only controls when code runs, not how layout is batched.

âŒ WRONG: rAF with thrashing inside
requestAnimationFrame(() => {
  el.style.width = '100px'; // WRITE
  el.offsetWidth;           // READ â†’ forced layout
  el.style.height = '200px';
  el.offsetHeight;
});


Layout is still forced multiple times in one frame.

8. âŒ WRONG: rAF Inside a Loop
for (let i = 0; i < 100; i++) {
  requestAnimationFrame(() => {
    el.style.width = i + 'px';
    el.offsetWidth;
  });
}


All 100 rAF callbacks run in the same frame, causing 100 forced layouts.

9. âœ… RIGHT: Batch Reads First, Then Writes
requestAnimationFrame(() => {
  // READ phase
  const width = el.offsetWidth;
  const height = el.offsetHeight;

  // WRITE phase
  el.style.width = width + 10 + 'px';
  el.style.height = height + 10 + 'px';
});


Only one layout is required.

10. âœ… RIGHT: One Layout per Frame (Chained rAF)
let i = 0;

function step() {
  const width = el.offsetWidth; // READ
  el.style.width = width + 1 + 'px'; // WRITE

  i++;
  if (i < 100) {
    requestAnimationFrame(step);
  }
}

requestAnimationFrame(step);


Layout occurs once per frame, which is expected and safe.

11. Best Practice: Avoid Layout When Possible

Prefer properties that do not trigger layout:

âŒ Avoid

top, left

width, height

margin, padding

âœ… Prefer
transform: translate();
opacity: 0.8;


These are handled by the compositor and do not cause layout thrashing.

12. How to Detect Layout Thrashing

Chrome DevTools â†’ Performance tab

Look for:

â€œForced reflowâ€

Long â€œLayoutâ€ tasks

Warnings in console for layout reads after writes

13. One-Line Interview Answer

Layout thrashing occurs when interleaved DOM writes and layout reads force repeated synchronous layout recalculations, blocking the main thread and causing dropped frames.

14. Final Mental Model

DOM writes make layout dirty; layout reads demand it be clean â€” alternating them forces the browser to repeatedly redo layout work.


---

If you want, next I can:
- Add **visual ASCII diagrams**
- Convert this into **flash cards**
- Reduce it to **5 interview bullets**
- Add **React / framework examples**
- Add **DevTools screenshots explanation**

Just say ğŸ‘

Give this 14 points in one mdx file please 

Got it ğŸ‘
Here is ONE clean MDX file containing exactly the 14 points, concise, structured, and perfect for interview revision. No extra fluff.

You can save this as something like layout-thrashing.mdx.

---
title: Layout Thrashing â€” 14 Point Summary
description: Interview-ready notes explaining layout thrashing, browser internals, event loop, vsync, and correct patterns.
---

# Layout Thrashing â€” 14 Key Points

---

## 1. What Is Layout Thrashing?

Layout thrashing happens when JavaScript **alternates between DOM writes and layout-dependent reads**, forcing the browser to recalculate layout repeatedly.

---

## 2. Browser Optimization Strategy

Browsers **delay layout work** for performance.  
DOM writes only **mark layout as dirty**, they do not immediately recalculate it.

---

## 3. What Marks Layout Dirty?

Any DOM write such as:
- `style.width`
- `style.height`
- `classList.add`
- inserting/removing elements

This tells the browser: *layout is no longer valid*.

---

## 4. Layout-Dependent Reads

These APIs require layout to be clean:
- `offsetWidth / offsetHeight`
- `getBoundingClientRect()`
- `clientWidth / clientHeight`
- `scrollTop / scrollHeight`

---

## 5. Forced Synchronous Layout

If layout is dirty and a layout read occurs, the browser **must immediately recalculate layout**, blocking JavaScript execution.

This is called a **forced reflow**.

---

## 6. How Thrashing Happens

Thrashing occurs when code does this repeatedly:



WRITE â†’ READ â†’ WRITE â†’ READ


Each read forces a layout recalculation.

---

## 7. Why Layout Thrashing Is Harmful

- Blocks the main thread
- Causes long JS tasks
- Exceeds the 16.6ms frame budget
- Leads to jank and dropped frames

---

## 8. Where It Happens in the Event Loop

Layout thrashing happens **during JavaScript execution**, before rendering begins.

Rendering cannot proceed until JavaScript and layout complete.

---

## 9. Relation to VSync

Excessive layout recalculations delay rendering, causing the browser to **miss vsync**, resulting in visible stutter.

---

## 10. requestAnimationFrame Is Not a Fix by Itself

`requestAnimationFrame` only controls *when* code runs.

If reads and writes are still interleaved inside rAF, layout thrashing still occurs.

---

## 11. âŒ Wrong Pattern (Thrashing)

```js
for (let i = 0; i < 100; i++) {
  el.style.width = i + 'px'; // WRITE
  el.offsetWidth;            // READ â†’ forced layout
}


This forces layout 100 times.

12. âŒ Wrong Pattern (Multiple rAFs)
for (let i = 0; i < 100; i++) {
  requestAnimationFrame(() => {
    el.style.width = i + 'px';
    el.offsetWidth;
  });
}


All rAF callbacks run in the same frame, still thrashing.

13. âœ… Correct Pattern (Batch Reads and Writes)
requestAnimationFrame(() => {
  const width = el.offsetWidth; // READ
  el.style.width = width + 10 + 'px'; // WRITE
});


Only one layout is required.

14. Best Practice & Interview One-Liner

Batch all reads first

Batch all writes second

Prefer transform and opacity

Interview one-liner:

Layout thrashing is caused by interleaving DOM writes with layout reads, forcing repeated synchronous reflows that block the main thread and cause dropped frames.


---

If you want next:
- ğŸ”¹ **1-page printable cheat sheet**
- ğŸ”¹ **React-specific layout thrashing examples**
- ğŸ”¹ **Performance tab walkthrough**
- ğŸ”¹ **Animation best practices summary**

Just tell me ğŸ‘

    const ele = document.getElementById("layoutThrashing");
    let val = ele.getBoundingClientRect().width;
    for (let index = 0; index < 100; index++) {
       val =  val + 1;
       ele.style.width = val + 'px';
    }

is this layout thrashing

Great question â€” this is exactly the kind of edge case interviewers ask ğŸ‘
Letâ€™s be precise.

Short answer

No, this code is not layout thrashing.
It causes layout invalidation, but not thrashing, because the layout read happens only once, before all the writes.

Letâ€™s analyze it step-by-step
Your code
const ele = document.getElementById("layoutThrashing");
let val = ele.getBoundingClientRect().width; // READ (once)

for (let index = 0; index < 100; index++) {
   val = val + 1;
   ele.style.width = val + 'px'; // WRITE (100 times)
}

What the browser does internally
Step 1: Layout read
ele.getBoundingClientRect().width;


Browser checks layout state

If layout is dirty â†’ recalculates layout once

Returns width

Layout is now clean

âœ”ï¸ One forced layout (acceptable)

Step 2: Loop of writes
ele.style.width = ...


Each iteration:

Marks layout as dirty

Browser does not recalculate layout immediately

No layout reads after this

âœ”ï¸ Layout is recalculated later, only once during rendering

How many layouts actually occur?
Phase	Layout runs?
getBoundingClientRect()	âœ… Once
Loop writes	âŒ No
Rendering phase	âœ… Once

â¡ï¸ 2 layouts total, not 100.

Why this is NOT thrashing

Layout thrashing requires this pattern:

WRITE â†’ READ â†’ WRITE â†’ READ


Your pattern is:

READ â†’ WRITE â†’ WRITE â†’ WRITE â†’ ...


The browser can batch the writes.

Important nuance (still not perfect)

Although this is not thrashing, it can still be suboptimal:

Why?

100 synchronous style mutations

Might trigger style recalculation work

Can still be expensive for large DOM trees

But it does not force layout repeatedly.

Best possible version (minor improvement)
const ele = document.getElementById("layoutThrashing");
const startWidth = ele.getBoundingClientRect().width;

requestAnimationFrame(() => {
  ele.style.width = startWidth + 100 + 'px';
});


âœ”ï¸ One read
âœ”ï¸ One write
âœ”ï¸ One layout

Interview-grade conclusion

This code does not cause layout thrashing because it performs a single layout read followed by multiple writes, allowing the browser to batch layout work. Layout thrashing only occurs when reads and writes are interleaved.

Final mental rule (lock this in)

Multiple writes are fine. Multiple readâ€“write alternations are not.

If you want next:

How this behaves inside rAF

When style recalculation vs layout happens

How CSSOM invalidation differs

How browsers optimize width changes

How to detect â€œalmost thrashingâ€ cases

Just say ğŸ‘